#!/usr/bin/env python3

import argparse
import socket
import ssl
from html.parser import HTMLParser

DEFAULT_SERVER = "proj5.3700.network"
DEFAULT_PORT = 443

inputs = []

class MyHTMLParser(HTMLParser):
    print("herereree")
    def handle_starttag(self, tag, attrs):
        if tag == "input":
            print("Found an input element:", attrs)
            inputs.append(attrs)
    # def unknown_decl(self, data): #: str) -> None:
    #     # return super().unknown_decl(data)
    #     print("unknown data")
    #     print(data)



class Crawler:
    def __init__(self, args):
        self.server = args.server
        self.port = args.port
        self.username = args.username
        self.password = args.password



    # Get 
    # Post to login

    def run(self):
        #Accept-Encoding: gzip, deflate
        request = "GET /accounts/login/?next=/fakebook/ HTTP/1.1\r\nHost: " + DEFAULT_SERVER + "\r\n\r\n" #+ "\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)\r\n" + "Accept-Language: en-us\r\n\r\n"
        # need path, host, cookie
        # Cookie : whatever the cookie is
        # 302 - redirect; x has moved to location y in Location: header field
        # very first request will be logging in, get the cookie after the response
        # should use keep-alive or create a new TCP connection for each request
        

        """






        in our requests we have to 
        - keep-alive. i don't wanna open upneiofhwuerf
        - include csrf token + session ID from the first HTTP request we sent (both of these make up the cookie)
        Set-Cookie: csrftoken=Tc3sy8rm3ADcYfVQqKVrjHP87VUtVn6ADjt5pffCovmj1Ous9kLIsCdmDv
        Set-Cookie: sessionid=qrfww4f0b82wci0p8m3qy66ol76sbfc3; expires=Wed, 05 Apr 2023 17:50:57 GMT; HttpOnly; Max-Age=1209600; Path=/; SameSite=Lax 
        
        # response.split()
        #
        Questions:
        - Why is the loop taking forever to run
        separately
        - How to put the cookies in the header, just append or put separately
        - Should we post and then parse for links or parse and then post
        - Should we use the set-cookie in the response or the set-cookie in the <input type...>
        - How to get cookie from parser
        - grabbing csrfmiddlware from tuples
        - What link to send to
        """

        print("Request to %s:%d" % (self.server, self.port))
        print(request)
        mysocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_context = ssl.create_default_context()
        mysocket = ssl_context.wrap_socket(mysocket, server_hostname=DEFAULT_SERVER)
        mysocket.connect((self.server, self.port))

        print("before first send")
        mysocket.send(request.encode('ascii'))

        # have to receive in a loop (len(data != 0))

        """
        
        """

        firstResp = b''
        print("before first recv")
        data = mysocket.recv(1000)
        print("Response: ")
        while len(data) != 0:
            print("DATA LENGTH: " + str(len(data)))
            print(data.decode('ascii'))
            firstResp += data#.decode('ascii')
            #print("Zezerofibo Mishveladze")
            # if len(data) == 0:
            #     print("no more data")
            if len(data) < 1000:
                break
            data = mysocket.recv(1000)
            print("DATA LENGTH: " + str(len(data)))
            

            #print("here?")
        
        print("done reading")
        mysocket.close()

        parser = MyHTMLParser()

        contLenHead = b'Content-Length: '
        index = firstResp.find(contLenHead)
        if index != -1:
            start = index + len(contLenHead)
            end = firstResp.find(b'\r\n', start)
            contentLength = int(firstResp[start:end])
            print("Content len " + str(contentLength))
        
        firstResp = firstResp.decode('ascii')
        headers = []
        headers = firstResp.split('\r\n\r\n')[0].split('\r\n')
        headDict = {}
        next = False
        secondCookieFull = ""
        csrftokenFull = ""
        for header in headers[1:]:
            key, value = header.split(': ')
            headDict[key] = value
            if str(key) == "Set-Cookie":
                if next:
                    secondCookieFull = value
                    break
                else:
                    csrftokenFull = value
                next = True
        
        splitcsrfToken = csrftokenFull.split(';')
        csrftoken = splitcsrfToken[0]
        splitSecondCookie = secondCookieFull.split(';')
        secondCookie = splitSecondCookie[0]
        print("csrftoken " + str(csrftoken))
        print("second cookie " + str(secondCookie))


        parser.feed(firstResp)
        # loop through the list that we receive
        """
        [('type', 'hidden'), ('name', 'csrfmiddlewaretoken'), ('value', 'GFOtaI7xehVXKasiWBF8S1ImE5x16Jpnai5Yb6jpit0qWp0LQYh20KXOlACqI8qT')]
        for attr in attrs:
            if attr[0] == "name":
                if attr[1] == 'csrfmiddlewaretoken':
                    # try to find value attribute
                    # keep the corresponding value (the token)
        """
        
        cookie = ''
        cmtval = None
        foundCMT = False

        for input in inputs:
            print(input)
            # input is of form:
            for tup in input:
                if tup[0] ==  "name" and tup[1] == "csrfmiddlewaretoken":
                    foundCMT = True 
                    break
            # if we found the token
            if foundCMT:
                # find the value within the list
                for tup in input:
                    if tup[0] == "value":
                        cmtval = tup[1]
                        break
                break
            
                
        
        if not foundCMT:
            print("did not find CMT in the input tags")
            cmtval = None
        else:
            print("found csrfmiddlewaretoken: " + cmtval)
            
            # for att in input:
            #     if next:
            #         cookie == att[1]
            #         next = False
            #         break
            #     elif att[1] == 'csrfmiddlewaretoken':
            #         next = True
        
            # if input['name'] == 'csrfmiddlewaretoken':
            #     print('middle')
        #HTMLParser.feed(firstResp)
            

        # request = "GET /accounts/login/?next=/fakebook/ HTTP/1.1\r\nHost: " + DEFAULT_SERVER + "\r\n\r\n"
        #POST /users/login HTTP/1.1HOST: www.example.com Content-Type: application/x-www-form-urlencoded Content-Length: 25 username=ME&password=pass
        body = 'username=calle.d&password=001589490' + '&csrfmiddlewaretoken='+ cmtval + '&next=/ \r\n\r\n'  #+ '&next=/fakebook/'  #&csrfmiddlewaretoken=<CSRF_TOKEN>&next=/fakebook/'
        contLen = len(body)
        
        print("body " + str(body))
        postReq = 'POST /accounts/login/ HTTP/1.1\r\nHost: proj5.3700.network\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: ' + str(contLen) + '\r\nCookie: ' + csrftoken +  ';' + secondCookie + '\r\n\r\n' + body + '\r\n\r\n' # + '&csrfmiddlewaretoken=' + cmtval  #  
        print("THIS IS THE PSOT REQUEST W E ESENT")
        print(postReq)
        #postReq = "POST /accounts/login/ HTTP/1.1\r\nHOST: " + DEFAULT_SERVER + "\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: {contLen}\r\n" + "{body}\r\n\r\n" #+ #"Set-Cookie: csrftoken={cmtval}\r\nSet-Cookie: sessionid={secondCookie}\n\n{body}\r\n\r\n"
        
        # use content-length to read the body of the responses
        mysocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_context = ssl.create_default_context()
        mysocket = ssl_context.wrap_socket(mysocket, server_hostname=DEFAULT_SERVER)
        mysocket.connect((self.server, self.port))
        
        print("before sending")
        mysocket.send(postReq.encode('ascii'))
        
        data = mysocket.recv(1000)
        # print("Response after POST: ")
        # print(data)

        contLenHead = b'Content-Length: '
        index = data.find(contLenHead)
        if index != -1:
            start = index + len(contLenHead)
            end = data.find(b'\r\n', start)
            contentLength = int(data[start:end])
            print("Content len " + str(contentLength))

        # ind1 = data.find("Content-Length:")
        # cont_len = int(data[ind1+1])
        # print("GRABBED CONTENT LENGTH " + str(cont_len))


        
        
        

        while len(data) != 0:
            print(data.decode('ascii'))
            #print("Dougal Trufull")
            # if len(data) == 0:
            #     print("no more data")
            
            if len(data) < 1000:
                break;

            data = mysocket.recv(1000)
        
        mysocket.close()

            #print("here?")
        # Post url HTTP/1.1\r\nHost: " + DEFAULT_SERVER + "\r\n\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: {len(encoded_data)}\r\n\r\n{encoded_data.decode('utf-8')}"

        #data = mysocket.recv(2048)
        # print("data???")
        # print(data)
        # print("Response:\n%s" % data.decode('ascii'))
        # how to download
        """
        request response has a header and a body
        the body has the html, can be encrypted/compressed (in which case we need to decode)
        need to look for 3 tags: <a>, <input>, <h2>
            - <input/> - harvest the middleware token
        to actually save the session, use the csrf middleware token
            that goes into our cookie (has session ID)
        usually on the fakebook website there's an input tag w a name and a csrf token and the value is our csrf token

        eventually gonna want to harvesvt two things form the response:
            - gives us a csrf middleware token, which is half of the cookie, and a session id
            - both things are parameters of our get request
        where does it go into the get request? does not need it
        get request needs path, host, cookie
        post request also needs middleware token

        

        """

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='crawl Fakebook')
    parser.add_argument('-s', dest="server", type=str, default=DEFAULT_SERVER, help="The server to crawl")
    parser.add_argument('-p', dest="port", type=int, default=DEFAULT_PORT, help="The port to use")
    parser.add_argument('username', type=str, help="The username to use")
    parser.add_argument('password', type=str, help="The password to use")
    args = parser.parse_args()
    sender = Crawler(args)
    sender.run()
